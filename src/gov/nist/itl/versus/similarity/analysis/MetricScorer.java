/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of
 * their official duties. Pursuant to title 17 Section 105 of the United
 * States Code this software is not subject to copyright protection and is
 * in the public domain. This software is an experimental system. NIST assumes
 * no responsibility whatsoever for its use by other parties, and makes no
 * guarantees, expressed or implied, about its quality, reliability, or
 * any other characteristic. We would appreciate acknowledgment if the
 * software is used.
 *
 *
 *    Date: 08-09-2013
 */


package gov.nist.itl.versus.similarity.analysis;

/**
 * As of 08-09-2013, the most recent scoring method for metrics
 * 
 * Used after: pearson_by_folder
 * 
 * Has one static method that returns a transform-feature-measure metric, 
 * and writes a csv file of scores for every possible metric given
 * an array of ints saying whether a folder is of interest, the
 * directory generated by the "batch_graph_compare" python program, 
 * and a output file name, without a filetype. The csv will be created
 * in a subfolder named "scores" in the directory passed in. 
 * 
 * Scoring Method:
 * 		1- load all possible metric-change correlation values, 
 * 		  given a metric. 
 * 		2- Subtract each metric-change correlation from 1 or 0, 
 * 		  depending on whether the type of change is specified as 
 * 		  one of interest or not, respectively
 * 		3- Sum all of the differences for metric-change combination 
 * 		  for a given metric. This is the metric's score
 * 		4- The lowest score is the best. 
 *      
 * 
 * @author Cynthia Gan (cng1)
 */

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class MetricScorer {
	// Index starts from 0, column the transformation applied is in
	private final static int TRANS_COL = 0;
	// Index starts from 0, column the descriptor is in
	private final static int DESCRIPTOR_COL = 1;
	// Index starts from 0, column the measure is in
	private final static int MEASURE_COL = 2;
	// Index starts from 0, column the regression name is in
	private final static int PEARSON_COL = 3;
	private final static String SPLIT_CHAR = ",";
	// what suffix all the spreadsheets have
	private final static String FILE_SUFFIX = "-pearson.csv";
	// what sub-folder all the answer score sheet will be in
	private final static String SUBFOLDER = "scores";

	// Guide to what folders the booleans should refer to:
	private final static String[] FOLDERS = { "intensity-Blur-FourColorBox",
			"intensity-Gamma-FourColorBox",
			"intensity-NoiseGauss-FourColorBox", "intensity-NoiseGauss-Shaded",
			"intensity-NoiseUnif-Shaded", "intensity-NoiseUnif-FourColorBox",
			"position-NoiseGauss-Center", "position-NoiseGauss-FourColorBox",
			"position-NoiseGauss-Center", "position-NoiseGauss-FourColorBox",
			"position-NoiseUnif-Center", "position-NoiseUnif-FourColorBox",
			"position-Rotation", "position-Translation", "shape-Ellipticity",
			"shape-NoiseGauss-CircleWidth", "shape-NoiseGauss-DiskBnd",
			"shape-NoiseUnif-CircleWidth", "shape-NoiseUnif-DiskBnd",
			"shape-Scaling", "texture-CheckerGranularity",
			"texture-CheckerOrientation", "texture-NoiseGauss-LineOrient",
			"texture-NoiseGauss-LinePos", "texture-NoiseUnif-LineOrient",
			"texture-NoiseUnif-LinePos" };

	/**
	 * 
	 * @param options
	 *            an array of 1s or 0s that state whether the corresponding
	 *            folder is of interest, 1 is of interest, 0 is not
	 * @param main_dir
	 *            the main folder that contains the "gov.nist.itl.versus.similarity.analysis" folder of
	 *            regression gov.nist.itl.versus.similarity.analysis of all the folders.
	 * @return recommendations for transform-feature-measure, with the
	 *         corresponding best regressions for each folder of interest, The
	 *         result will be returned as: {"transform", "feature",
	 *         "measure"}
	 * @throws IOException 
	 */
	public static String[] find_best(int[] options, String main_dir, String file_out_name) throws IOException {
		// Number of folders selected
		String[] result = new String[3];
		// String[] info_string = new String[26];
		String[] min_row = null;

		// Get paths to the relevant files based off the boolean options and a
		// root directory
		String[] filePaths = getFiles(main_dir);
		
		// Create a file to write all the scores to and write a header
		String out_path = main_dir + File.separator + SUBFOLDER;
		new File(out_path).mkdirs(); // Make directory if doesn't exist
		BufferedWriter writer = new BufferedWriter(new FileWriter(out_path + File.separator + file_out_name + ".csv"));
		String header_string = "Transform,Feature,Measure,Score\n";
		writer.write(header_string);

		// Create a file reader for each file, store it in an array
		BufferedReader[] readers = new BufferedReader[filePaths.length];
		for (int i = 0; i < filePaths.length; i++)
			try {
				readers[i] = new BufferedReader(new FileReader(filePaths[i]));
				readers[i].readLine(); // Skip first line which is just a header
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}

		double sum = 0;
		double min = Double.MAX_VALUE;
		String line = "";

		try {
			// Search through all the lines of a file
			while ((line = readers[0].readLine()) != null) {

				// Pull a row's worth of information from the first file with
				// the first reader and save it temporarily
				sum = 0;
				String[] row = line.split(SPLIT_CHAR);

				// Save the names of the comparison options to ensure the right
				// row is being summed in the other files
				String[] refRow = row;
				
				if (row.length != 0) {
					// Part of Step 2 and Step 3
					double new_val = Math.abs(options[0]*1 - filterValue(row[PEARSON_COL]));
					sum += new_val;

					// Step 2 and Step 3 continued
					// Sum all the fitnesses for a cumulative fitness value
					for (int i = 1; i < readers.length; i++) {
						// Only add them if they are the corresponding row
						if (properlyPaired(refRow, row)) {

							// Pull a row's worth of information, and save it
							// temporarily
							line = readers[i].readLine();
							row = line.split(SPLIT_CHAR);

							if (row.length != 0){
								new_val = Math.abs(options[0]*1 - filterValue(row[PEARSON_COL]));
								sum += new_val;
							}
						} else {
							System.out.println(i + " "  + FOLDERS[i]);
							System.exit(0);
						}
					}
						// If the current row the lowest sum thus far
						// save everything about the row to return. 
						if (sum < min) {
							min = sum;
							min_row = row;
						}
						
						// Write the row and its score to the file
						String score_string = row[TRANS_COL] + "," + row[DESCRIPTOR_COL] + "," + row[MEASURE_COL]  
								+ "," + String.format("%.15f", sum) + "\n";
						writer.write(score_string);
						writer.flush();
					
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		}

		// Close all i/o
		for (int i = 0; i < readers.length; i++)
			readers[i].close();
		writer.close();
		
		// Package the results into the desired array structure
		result[0] = min_row[TRANS_COL];
		result[1] = min_row[DESCRIPTOR_COL];
		result[2] = min_row[MEASURE_COL];
		return result;
	}

	/**
	 * Get paths to the relevant files based off the boolean options and a root
	 * directory
	 * 
	 * @param options
	 *            array of ints that state whether the corresponding
	 *            folder is of interest
	 * @param mainDir
	 *            folder containing csv files named similarly to 
	 * 			  types of change, containing the correlation values.
	 * @return array of paths to each of the csv files containing 
	 * 			correlation coefficients
	 */
	private static String[] getFiles(String mainDir) {

		String[] paths = new String[FOLDERS.length];
		int index = 0;
		for (int i = 0; i < FOLDERS.length; i++) {
				String file = mainDir + File.separator
						+ FOLDERS[i] + FILE_SUFFIX;
				paths[index++] = file;
		}
		return paths;
	}

	/**
	 * Filters out measures without valid regression by replacing the 
	 * fitness value with -999, effectively knocking those measures out of the
	 * running for best fit. They filter out cells filled with "None" and "inf"
	 * 
	 * @param value
	 *            string containing the pearson coefficient
	 * @return absolute value of correlation or 999 if no regression was possible
	 */
	private static double filterValue(String value) {
		double filtered = 0;
		if (value.equalsIgnoreCase("None") || value.equalsIgnoreCase("nan")  || value.equalsIgnoreCase("inf")) {
			filtered = 999;
		} else {
			filtered = Math.abs(Double.parseDouble(value));
		}
		return filtered;
	}

	/**
	 * Checks whether a row corresponds to the reference row (e.g. the row most
	 * recently read from the first file)
	 * 
	 * @param refRow
	 *            String array that is the row being compared of the first file
	 *            read, split into columns, used as a reference
	 * @param row
	 *            String array containing the row being compared of the file
	 *            currently being read, split into columns
	 * @return boolean whether the rows are the same
	 *         transform-descriptor-measure
	 */
	private static boolean properlyPaired(String[] refRow, String[] row) {
		if (refRow == null
				|| (row[TRANS_COL].equalsIgnoreCase(refRow[TRANS_COL])
						&& row[MEASURE_COL]
								.equalsIgnoreCase(refRow[MEASURE_COL]) && row[DESCRIPTOR_COL]
							.equalsIgnoreCase(refRow[DESCRIPTOR_COL])))
			return true;
		else {
			System.err.println("Bad pair: ");
			System.err.println("\trow:" + row[TRANS_COL] + " " + row[DESCRIPTOR_COL]  + " " + row[MEASURE_COL]);
			System.err.println("\tref:" + refRow[TRANS_COL] + " " + refRow[DESCRIPTOR_COL]  + " " + refRow[MEASURE_COL]);
			return false;
		}
	}

	// Debugging tool that converts a string array to a string
	public static String arrToString(String[] arr) {
		String res = "";
		for (int i = 0; i < arr.length; i++) {
			res = res + " " + arr[i];
		}
		return res;
	}

}
